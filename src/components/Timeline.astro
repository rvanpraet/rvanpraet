---
import type { HTMLAttributes } from 'astro/types'
import { twMerge } from 'tailwind-merge'
import Tag from './Tag.astro'

interface Props extends HTMLAttributes<'section'> {
  items: Array<{
    dateFrom: string
    dateTo?: string
    title: string
    subtitle?: string
    description: string
    tags?: string[]
  }>
}

const { items, class: classList, ...rest } = Astro.props

const componentClasses = 'timeline-component'

const classes = twMerge(componentClasses, classList)
---

<section class={classes} {...rest}>
  <ul class="list-none p-0">
    {
      items.map((item, index) => (
        <li class="timeline-item main-grid-layout relative flex flex-row gap-8 w-full mb-16">
          <div class="timeline-date-range col-start-1 col-span-1 pr-2 sm:pr-8 md:col-start-2 md:pr-16 max-lg:pl-4 lg:col-start-4 lg:col-span-2 3xl:col-start-5 text-sm">
            <span class="timeline-daterange-to pb-2">{item.dateTo}</span>
            <div class="timeline-date-separator" />
            <span class="timeline-daterange-from pt-2">{item.dateFrom}</span>
          </div>
          <div class="col-start-2 col-span-3 md:col-start-3 md:col-span-4 lg:col-start-6 lg:col-span-7 2xl:col-span-6 max-lg:pr-4 lg:pr-12 2xl:pr-0">
            <h2 class="text-2xl lg:text-3xl 3xl:text-4xl font-semibold uppercase mb-0!">{item.title}</h2>
            {item.subtitle && (
              <h3 class="text-lg xl:text-xl 2xl:text-2xl font-light timeline-item-subtitle">{item.subtitle}</h3>
            )}
            {item.tags && item.tags.length > 0 && (
              <div class="flex flex-wrap gap-2 mt-4">
                {item.tags.map((tag) => (
                  <Tag>{tag}</Tag>
                ))}
              </div>
            )}
            <p class="text-paragraph mb-0! mt-8" set:html={item.description} />
          </div>
        </li>
      ))
    }
  </ul>
</section>

<style lang="scss">
  .timeline-item {
    .timeline-date-range {
      font-weight: var(--font-weight-normal);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      margin-top: calc(var(--spacing) * 2);
      min-height: 100px;
      min-width: 60px;
    }

    .timeline-date-separator {
      width: 100%;
      height: 100%;
      background-color: var(--color-white);
    }

    &:nth-child(even) {
      .timeline-daterange-from {
        align-self: center;

        @media screen and (min-width: 640px) {
          align-self: flex-start;
        }
      }
      .timeline-daterange-to {
        align-self: center;
        @media screen and (min-width: 640px) {
          align-self: flex-end;
        }
      }
    }

    &:nth-child(odd) {
      .timeline-daterange-from {
        align-self: center;
        @media screen and (min-width: 640px) {
          align-self: flex-end;
        }
      }
      .timeline-daterange-to {
        align-self: center;
        @media screen and (min-width: 640px) {
          align-self: flex-start;
        }
      }
    }
  }
</style>

<script>
  import { isXS } from '@/scripts/utils/breakpoints'

  const initDateSeparators = () => {
    document.querySelectorAll('.timeline-date-separator').forEach((el: HTMLElement, index) => {
      el.style.width = `100%`

      // Rotate the element based on its index (odd/even)
      const sign = index % 2 === 0 ? -1 : 1

      // Calculate angle of rotation based on width and height
      const { width, height } = el.getBoundingClientRect()

      // No rotation for extra small screens
      const angle = isXS() ? 0 : 90 - Math.atan2(height, width - 32) * (180 / Math.PI)

      // Set the rotation of the element
      el.style.transform = `rotate(${angle * sign}deg)`
      el.style.transformOrigin = 'center center'
      el.style.width = `${2}px`
    })
  }

  document.addEventListener('DOMContentLoaded', () => {
    initDateSeparators()
  })

  window.addEventListener('resize', () => {
    initDateSeparators()
  })
</script>
